= Команды двоичной арифметики: сложение, вычитание, умножение и деление

*Сложение и вычитание *чисел выполняется по правилам, аналогичным сложению и вычитанию по модулю $2^k$ , принятым в математике.

В Ассемблере, если в результате получается более $k$ разрядов, то $(k + 1)$-й пересылается в флаг CF.


$
  X + Y = cases(
    (X + Y ) mod 2^k = X + Y\, & space "CF" = 0\, & space "если" X + Y < 2^k,
    (X + Y ) mod 2^k = X + Y − 2^k\, & space "CF" = 1\, & space "если" X + Y gt.eq 2^k
  )
$


Пример (для байтов):

$ 250 + 10 = 260 = 100000100_2, "и результат:" 00000100_2 = 4, space "CF" = 1 $

$
  X − Y = cases(
    (X − Y ) mod 2^k = X − Y\, & space "CF" = 0\, & space "если" X gt.eq Y,
    (X − Y ) mod 2^k = X + 2^k − Y\, & space "CF" = 1\, & space "если" X < Y
  )
$

Пример (для байтов):

$ 1 − 2 = 1 + 2^8 − 2 = 257 − 2 = 255, space "CF" = 1 $

Важно помнить, что компьютеры не умеют "вычитать". Любая операция вычитания требует предварительного перевода вычитаемого числа в дополнительный код (_two’s complement_).

Например, в том же примере 1 --- 2, к результату можно прийти так:
$
  −2 = −00000010_2 \
  "Доп. код:" 2^8 − 2 = 11111110_2 \
  1 − 2 = 00000001_2 + 11111110_2 = 11111111_2, "CF" = 1, \
  "так как был заем для старшего разряда".
$

Результат можно интерпретировать по-разному: как беззнаковое число 255 или как дополнительный код знакового числа −1. То есть компьютеру не важно, знаковая операция или беззнаковая. Программист сам решает это, исходя из задачи и ориентируясь на флаги.

Арифметические операции изменяют флаги OF, CF, AF, PF, ZF, SF.

== Сложение

- ```asm
  add R/M, R/I ; к R/M прибавить R/I,
  add R, M
  ```
- ```asm
  xadd R/M, R ; обменять операнды местами, после выполнить сложение (i486 и новее)
  ```
- ```asm
  adc R/M, R/I ; add with carry, прибавить второй операнд к первому, после прибавить значение флага CF
  adc R, M
  ```

- ```asm
  inc R/M ; прибавить 1 к R/M
  ```

== Вычитание

- ```asm
  sub R/M, R/I ; из R/M вычесть R/I
  sub R, M
  ```

- ```asm
  sbb R/M, R/I ; subtract with borrow, вычесть второй операнд из первого, после вычесть значение флага CF
  sbb R, M
  ```

- ```asm
  dec R/M ; вычесть 1 из R/M
  ```

== Умножение

- ```asm
  mul R/M ; беззнаковое умножение AL/AX/EAX на R/M
  ```
  Умножать непосредственно на число нельзя, нужно через R/M.

  #table(
    columns: (auto, 5.6em, auto),
    table.header([*Размер операнда*], [*Действие*], [*Результат*]),
    [`byte`], [AL #h(1fr) $*$ R/M], [AX],
    [`word`], [AX #h(1fr) $*$ R/M], [DX:AX],
    [`dword`], [EAX #h(1fr) $*$ R/M], [EDX:EAX],
  )

- ```asm
  imul R/M ; знаковое умножение AL/AX/EAX на R/M
  imul R, R/M/I ; умножить R на R/M/I и результат записать в R (с i386)
  imul R, R/M, I ; умножить R/M на I и результат записать в R (с i186)
  ```
  Если в результате умножения $"CF" = "OF" = 1$, то результат занимает двойной формат, если $"CF" = "OF" = 0$, то результат уместился в размере одного сомножителя.

== Деление

- ```asm
  div R/M ; беззнаковое деление
  ```
  Делить непосредственно число нельзя, нужно через R/M.

  #table(
    columns: (auto, 8.1em, auto, auto),
    table.header([*Размер операнда*], [*Действие*], [*mod*], [*div*]),
    [`byte`], [AX #h(1fr) $div$ R/M], [AH], [AL],
    [`word`], [DX:AX #h(1fr) $div$ R/M], [DX], [AX],
    [`dword`], [EDX:EAX #h(1fr) $div$ R/M], [EDX], [EAX],
  )

- ```asm
  idiv R/M ; знаковое деление
  ```

Программисту нужно следить, чтобы случайно не разделить на 0.

*Замечание*: `R` --- регистр, `M` --- адрес в памяти, `I` --- непосредственное значение (immediate value).

