= Процессор с точки зрения программиста, регистры общего назначения, регистр флагов

C точки зрения программиста *архитектура процессора* --- это совокупность его программно доступных средств.

*Регистр* --- набор из $n$ устройств (*триггеров*) способный поразрядно хранить двоичное число.

Начиная с i386 процессора программисту доступны 16 *основных регистров*, 11 *регистров для работы с сопроцессором и мультимедийными приложениями*, и в реальном режиме доступны некоторые регистры управления и некоторые специальные регистры.

Основные регистры в i386:
- Общего назначения: EAX, EBX, ECX, EDX;
- Регистры индексов и указателей: ESI, EDI, ESP, EBP;
- Сегментные регистры: DS, ES, FS, GS, CS, SS;
- Счетчик (указатель) команд --- EIP;
- Регистр флагов --- EFLAGS.

Регистры общего назначения могут использоваться для временного хранения адресов и данных. При работе с 16-разрядными данными к ним можно обращаться как AX, BX, CX, DX, а при работе с байтами --- к старшей (верхней) и младшей (нижней) части 16-разрядного регистра, например, AH и AL.

Регистры общего назначения имеют названия, связанные с их функцией:
- AX --- аккумулятор (накопление);
- BX --- база (адресация операндов по базе);
- CX --- счетчик (организация циклов);
- DX --- регистр данных;

Регистр *флагов* FLAGS (EFLAGS) определяет состояние процессора и программы в каждый момент времени:

#table(
  columns: 22,
  inset: 10pt,
  align: center,
  table.header(
    [31],
    [...],
    ..range(19, -1, step: -1).map(i => [#i]),
  ),

  table.cell(fill: gray)[],
  table.cell(fill: gray)[],
  table.cell(fill: gray)[],
  [AC], [VM], [RF],
  table.cell(fill: gray)[],
  [NT], [IO], [PL], [OF], [DF], [IF], [TF], [SF], [ZF],
  table.cell(fill: gray)[],
  [AF],
  table.cell(fill: gray)[],
  [PF],
  table.cell(fill: gray)[],
  [CF],
)

- CF --- флаг переноса (беззнаковое переполнение); устанавливается в  1, если производится перенос за разрядную сетку при сложении или заем для старшего разряда при вычитании. Пример для 4-битных регистров:

  $1111_2 + 0001_2 = 0000_2, "CF" = 1;$

  $0000_2 − 0001_2 = 0000_2 + 1111_2 = 1111_2, "CF" = 1.$

- PF --- флаг четности; устанавливается в 1, если в младшем байте результата содержится четное число единиц.
- AF --- флаг полупереноса (Auxiliary Flag); устанавливается в 1, если при сложении происходит перенос из 3-го разряда в 4-й или если при вычитании происходит заем из 4-го разряда в 3-й.
- ZF --- флаг нуля; устанавливается в 1, если результат равен 0.
- SF --- флаг знака; равен знаковому разряду результата.
- TF --- флаг трассировки; если установлен в 1, то прерывает работу процессора после каждой команды.
- IF --- флаг прерывания, с помощью него можно запретить некоторые прерывания.
- DF --- флаг обработки строк; если установлен в 0, то обработка идет в направлении увеличения адресов, если в 1 --- в направлении уменьшения адресов.
- OF --- флаг знакового переполнения; устанавливается в 1, если в результате знаковой операции произошло переполнение. То есть если у обоих операндов знаковые биты равны одному значению, а после выполнения операции результат имеет другое значение знакового бита. Пример для 4-битных регистров:

  $0100_2 + 0100_2 = 1000_2, "OF" = 1;$

  $1000_2 + 1000_2 = 0000_2, "OF" = 1.$

- AC --- флаг выравнивания операндов; если 1 и адреса операндов длиной в слово или двойное слово не кратны 2 и 4 соответственно, происходит ошибка.
- VM --- флаг виртуальных машин; защищенный режим или режим виртуальной машины.
- RF --- флаг маскирования прерывания; маскирование некоторых прерываний процессора.
- NT --- флаг вложенной задачи; режим работы вложенных задач.
- IOPL --- флаг уровеня привелегий ввода/вывода; если уровень привелегий для текущей программы меньше или равен значению IOPL, то программе разрешены операции ввода/вывода (инструкции in и out). На 8086 и i186 этот флаг всегда равен 1.

*Замечание*: при выполнении беззнаковых операций, флаг OF не дает никакой полезной информации, только CF. Аналогично, при выполнении знаковых операций, при проверке на ошибки, имеет значение только флаг OF.

*Еще одно*: непонятный флаг IOPL по идее контролирует выполнения операций ввода/вывода на кольцах ОС (RINGs). То есть если IOPL = 2, то коду на кольцах 0, 1 и 2 будет разрешено выполнять ввод и вывод. Получается, что в презентации (по крайней в той версии, которая у меня на руках) ошибка.
