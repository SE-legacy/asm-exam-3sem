= Команды условной передачи управления, организация циклов в Ассемблере с помощью команд передачи управления.

Общий вид *команды условной передачи управления*:

#align(center)[
  ```asm
  jX <метка> ; [комментарии]
  ```
]

где $X$ соответствует оному из условий для передачи управления. Если условие выполняется, то будет совершен прыжок, иначе выполнение продолжится следующей идущей командой.

\<метка> должна стоять от *jX* не дальше чем на --- 128 или 127 байт.

Передача управления осуществляется на основе значений флагов, которые установила предыдущая команда. Например, если после вычитания $Z F = 1$, то значит, что результат предыдущей был нулем, и прыжок *jz* выполнится.

Можно также напрямую "сравнить" два числа командой *cmp*. Она выполнит обычное вычитание второго операнда из первого, но результат никуда записан не будет.

Это установит некоторые флаги в значения, пригодные для сравнения одного числа относительно другого.

Существует также команда *test*, которая выполнит побитовое *and* над операндами и установит флаги в нужные значения (более предпочтительна при проверке чисел на равенство).

#set table.hline(stroke: .6pt)
#table(
  columns: 3, 
  stroke: none,
  inset: 10pt,
  align: center,
  table.hline(),
  table.header(
    [*Условие*], [*Для беззнаковых чисел*], [*Для знаковых чисел*],

  ),
  table.hline(),
  table.vline(x: 0),
  table.vline(x: 1),
  table.vline(x: 2),
  table.vline(x: 3),
  [>], [JA], [JG],
  table.hline(),
  [=], [JE], [JE],
  table.hline(),
  [\<], [JB], [JL],
  table.hline(),
  [>=], [JAE], [JGE],
  table.hline(),
  [\<=], [JBE], [JLE],
  table.hline(),
  [\<> или !=], [JNE], [JNE],
  table.hline(),
)

В принципе, по этой теме это все, что есть в презентации. Если кому-то захочется, можно еще попытаться разобраться в этом.

Для краткости предположим, что непосредственно перед оператором условной передачи управления была выполнена инструкция

#align(center)[
  ```asm
  cmp OP1, OP2
  ```
]

Тогда для перехода с условием
- Равно:
  - для беззнаковых и для знаковых (*je*). Если $Z F = 1 => O P 1 == O P 2$
- Больше или равно:
  - Для беззнаковых (*jae, jnb*). $O P 1 >= O P 2$, если нам не понадобится перенос разряда, то есть $C F = 0$.
  - Для знаковых (*jge, jnl*). Если $S F = 0$ и не было знакового переполнения или если $S F = 1$ и было знаковое переполнение, то $O P 1 >= O P 2$. Это условие можно упростить до $S F = O F$
- Больше (*ja, jnbe | jg, jnle*): точно такие же условия, что для "$>=$", но конъюнктивно добавляется условие $Z F = 0$, чтобы исключить равенство $O P 1$ и $O P 2$.
- Меньше:
  - Для беззнаковых (*jb, jnae*). $O P 1 < O P 2$, если нам понадобился перенос разряда, то есть $C F = 1$.
  - Для знаковых (*jl, jnge*). Если $S F = 0$ и было знаковое переполнение, или если $S F = 1$ и не было знакового переполнения, то $O P 1 < O P 2$. Или кратко, $S F eq.not O F$.
- Меньше или равно (*jbe, jna | jle, jng*): точно такие же условия, что для "$<$" но дизъюнктивно добавляется условие $Z F = 1$.

Если нужно совершить переход на метку, которая дальше --- 128 или 127 байтов, то следует инвертировать условие перехода, и сразу после инвертированного условного перехода добавить инструкцию безусловного перехода на нужную метку:

```asm
        ; cmp AX, BX
        ; je M      ; не можем, далеко!
        cmp AX, BX
        jne Cont
        jmp M
    Cont:
        ; ...
```

Организация *цикла с предусловием*:

```asm
l1: ; while x > 0 do S;
    cmp x, byte ptr 0
    jle e1
    ; S 
    jmp l1
e1:
    ; ...
```

Организация *цикла с постусловием*:

```asm
l1: ; do S while x > 0;
    ; S 
    cmp x, byte ptr 0
    jg l1
e1:
    ; ...
```
