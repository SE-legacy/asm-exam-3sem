#import "../functions.typ": int_XXh

= Установка указателя файла, поиск файла, переименование файла

== Функции DOS работы с файлами (`int 21h`)

+ #int_XXh("Установить указатель файла", 0x42)[
    BX $<-$ идентификатор файла;

    CX:DX --- на сколько переместить указатель: $("CX" * 65536) + "DX"$;

    AL $<-$ режим работы:
    - 0 --- переместить к началу файла + CX:DX;
    - 1 --- переместить к текущей позиции + CX:DX;
    - 2 --- переместить к концу файла + CX:DX.
  ][
    - CF = 0, DX:AX = новая позиция указателя от начала файла;
    - CF = 1 --- произошла ошибка:
      - AX = 06h --- неверный идентификатор.

    Вызов с AL = 2, CX = 0, DX = 0 возвращает длину файла в DX:AX: $("DX" * 65536) + "AX"$.

    Если ввести отрицательный указатель --- сообщение об ошибке. А если указатель станет больше размера файла --- размер файла увеличится.
  ]
+ #int_XXh("Поиск первого файла", 0x4E)[
    CX $<-$ атрибуты файла;

    DS:DX --- адрес спецификации файла, которая может содержать обобщающие символы `*` и `?`.
  ][
    - CF = 0, в область DTA (Disk Transfer Area) помещается имя, расширение и другая информация о найденном файле;
    - CF = 1 --- произошла ошибка:
      - AX = 02h --- файл не найден;
      - AX = 03h --- путь не найден;
      - AX = 12h --- неверный режим доступа.

    Область DTA --- это 128-байтный буфер, который находится в PSP со смещением по умолчанию равным 0080h, но его можно и переопределить с помощью функции 1Ah.
  ]
+ #int_XXh("Поиск следующего файла", 0x4F)[
    DTA = содержит данные от предыдущего вызова функции 4Eh или 4Fh.
  ][
    - CF = 0, в область DTA помещаются данные о найденном файле;
    - CF = 1 --- произошла ошибка:
      - AX = код ошибки.

    Если необходимо найти все файлы по шаблону, то можно выполнять эту функцию, пока CF не равен 1.
  ]
+ #int_XXh("Переименование файла", 0x56)[
    DS:DX --- адрес текущей спецификации файла;

    ES:DI --- адрес спецификации файла, на которую требуется заменить.
  ][
    - CF = 0;
    - CF = 1 --- произошла ошибка:
      - AX = код ошибки.
  ]


*Пример*: русские буквы Н заменим на латинскую H в файлах с расширением txt.

```asm
.model tiny
.code
org 100h

start:
          mov ah, 4Eh               ; поиск первого файла с расширенм txt
          xor CX, CX                ; файл не системный, не директория
          mov DX, offset spec_file  ; адрес спецификации файла
op_fl:
          int 21h
          jc finish     ; если CF = 1 - go to finish
          mov AX, 3D02h ; иначе открыть файл для чтения и записи

          mov DX, 80h + 1Eh  ; СФ в DS:DX содержится в DTA со смещением 1Eh
                            ; 80h - начало DTA в PSP
          int 21h
          jc find_next  ; если CF = 1, файл не открылся

          mov BX, AX         ; переслыаем дескриптор в BX
          mov CX, 1          ; считываем 1 байт
          mov DX, offset buf
read_byte:
          mov AX, 3Fh ; чтение из файла
          int 21h
          jc find_next ; если CF = 1 - ошибка
          dec AX
          js find_next     ; если AX = 0, переходим к следующему
          cmp byte ptr buf, 8Dh ; сравниваем с кодом русской буквы Н
          jne read_byte
          mov byte ptr buf, 48h  ; если нашли, заменяем на латинскую H
          mov AX, 4201h          ; перемещаем указатель файла на 1 назад
          dec CX
          dec CX
          mov DX, CX
          int 21h

          mov AH, 40h ; запись в файл
          inc CX
          inc CX
          mov DX, offset buf
          int 21h
          jmp short read_byte
find_next:
          mov AH, 3Eh ; закрыть текущий файл
          int 21h
          mov AH, 4Fh ; для поиска следующего файла
          mov DX, 80h
          jmp short op_fl
finish:   ret

          spec_file db '*.txt', 0
          buf label byte
end start
```
